const e={isPath:e=>Array.isArray(e)&&0===e.filter((e=>"number"!=typeof e)).length,equals(e,t){for(let s in e)if(e[s]!==t[s])return!1;return e.length===t.length},compare(e,t){const s=Math.min(e.length,t.length);for(let r=0;r<s;r++){if(e[r]<t[r])return-1;if(e[r]>t[r])return 1}return 0},ancestors(e){let t=[];for(let s=0;s<e.length;s++)t.push(e.slice(0,s+1));return t},common(e,t){let s=[],r=Math.min(e.length,t.length);for(let n=0;n<r&&e[n]===t[n];n++)s.push(e[n]);return s},isAfter(e,t){return 1===this.compare(e,t)},isAncestor(e,t){return e.length<t.length&&0===this.compare(e,t)},isDescendant(e,t){return e.length>t.length&&0===this.compare(e,t)},isChild(e,t){return e.length===t.length+1&&0===this.compare(e,t)},isBefore(e,t){return-1===this.compare(e,t)},next(e){if(0===e.length)throw new Error("传入的path的数组长度不能为0");let t=e[e.length-1];return e.slice(0,e.length-1).concat(t+1)},before(e){if(0===e.length)throw new Error("传入的path的数组长度不能为0");let t=e[e.length-1];if(0===t)throw new Error("传入的path不存在前继节点");return e.slice(0,e.length-1).concat(t-1)},endsAfter(e,t){const s=e.length-1,r=e.slice(0,s),n=t.slice(0,s),o=e[s],i=t[s];return this.equals(r,n)&&o>i},endsBefore(e,t){const s=e.length-1,r=e.slice(0,s),n=t.slice(0,s),o=e[s],i=t[s];return this.equals(r,n)&&o<i},endsAt(e,t){const s=e.length-1,r=e.slice(0,s),n=t.slice(0,s);return e[s],t[s],this.equals(r,n)},transform(e,t,s={}){let r=[...e],{path:n}=t,{direction:o="forward"}=s;switch(t.type){case"insert_node":(this.isAncestor(n,r)||this.endsBefore(n,r)||this.equals(r,n)||this.isBefore(n,r))&&r[n.length-1]++;break;case"remove_node":if(this.endsAfter(r,n)||this.isAfter(r,n))r[n.length]--;else if(this.equals(r,n)||this.isAncestor(n,r))return null;break;case"merge_node":this.equals(n,r)||this.endsBefore(n,r)||this.isBefore(n,r)?r[n.length-1]--:this.isAncestor(n,r)&&(r[n.length-1]--,r[n.length]+=t.count);break;case"split_node":this.equals(n,r)?"forward"===o||r[r.length-1]++:this.endsBefore(n,r)||this.isBefore(n,r)?r[n.length-1]++:this.isAncestor(n,r)&&r[n.length]>=t.count&&(r[n.length-1]++,r[n.length]-=t.count);break;case"move_node":let{newPath:e}=t;if(this.equals(n,e))return null;this.equals(n,r)?(this.endsAfter(e,n)&&e.length>n.length&&e[n.length]--,r=e):this.isAncestor(n,r)?(this.endsAfter(e,n)&&e.length>n.length&&e[n.length]--,r=e.concat(r.slice(n.length,r.length))):this.endsBefore(n,r)?(r[n.length-1]--,(this.endsBefore(e,r)||this.equals(e,r))&&r[e.length-1]++):this.endsBefore(e,r)?r[e.length-1]++:this.equals(e,r)&&r[r.length-1]++}return r}},t={compare(t,s){let r=e.compare(t.path,s.path);return 0===r?t.offset>s.offset?1:t.offset<s.offset?-1:0:r},isAfter(e,t){return 1===this.compare(e,t)},isBefore(e,t){return-1===this.compare(e,t)},equals:(t,s)=>e.equals(t.path,s.path)&&t.offset===s.offset,isPoint:t=>t.path&&t.offset&&e.isPath(t.path)&&"number"==typeof t.offset,transform(t,s,r={}){const{type:n,path:o}=s;let i=Object.assign({},t);switch(n){case"move_node":case"insert_node":i.path=e.transform(i.path,s,r);break;case"merge_node":i.path=e.transform(i.path,s,r),e.equals(i.path,o)&&(i.offset+=s.count);break;case"split_node":i.path=e.transform(i.path,s,r),e.equals(i.path,o)&&i.offset>=s.count&&(i.offset-=s.count);break;case"remove_node":if(e.equals(i.path,o)||e.isAncestor(o,i.path))return null;e.transform(i.path,s,r);break;case"insert_text":e.equals(i.path,o)&&i.offset>=s.offset&&(i.offset+=s.text.length);break;case"remove_text":if(e.equals(i.path,o)&&i.offset>s.offset){if(i.offset-s.offset<s.text.length)return null;i.offset-=s.text.length}}return i}},s={edges(e){let{from:t,to:s}=e;return[t,s]},end(e){let{from:t,to:s}=e;return s},equals:(e,s)=>t.equals(e.from,s.from)&&t.equals(e.to,s.to),includes(r,n){let{from:o,to:i}=r;if(e.isPath(n))return e.compare(o.path,n)<=0&&e.compare(i.path,n)>=0;if(t.isPoint(n))return t.compare(o,n)<=0&&t.compare(i,n)>=0;if(s.isRange(n)){let{from:e,to:t}=n;return s.includes(r,e)&&s.includes(r,t)}},intersection(e,r){let[n,o]=s.edges(e),[i,l]=s.edges(r),f=t.isAfter(n,i)?n:i,h=t.isBefore(o,l)?o:l;return t.isAfter(f,h)?null:{from:f,to:h}},isBackward(e){let[r,n]=s.edges(e);return t.isAfter(r,n)},isCollapsed(e){let[r,n]=s.edges(e);return t.equals(r,n)},isExpanded:e=>!s.isCollapsed(e),isForward:e=>!s.isBackward(e),isRange:e=>e.from&&t.isPoint(e.from)&&e.to&&t.isPoint(e.to),*points(e){yield[e.from,"from"],yield[e.to,"to"]},start(e){let{from:t}=e;return t}},r={isLocation:r=>e.isPath(r)||t.isPoint(r)||s.isRange(r)};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function n(e){return"[object Object]"===Object.prototype.toString.call(e)}function o(e){var t,s;return!1!==n(e)&&(void 0===(t=e.constructor)||!1!==n(s=t.prototype)&&!1!==s.hasOwnProperty("isPrototypeOf"))}const i={isText:e=>o(e)&&e.text&&"string"==typeof e.text,equals:(e,t)=>e.text===t.text,isTextList(e){return Array.isArray(e)&&0===e.filter((e=>!this.isText(e))).length},matches(e,t){for(const s in t)if("text"!==s&&(!e.hasOwnProperty(s)||e[s]!==t[s]))return!1;return!0},decorations(e,t){let s=[Object.assign({},e)];for(let e of t){let{from:t,to:r}=e,n=[],o=0;for(let e of s){let{text:s}=e,i=o;if(o+=s.length,r.offset<=i||t.offset>=o){n.push(e);continue}if(t.offset<=i&&r.offset>=o){n.push(e);continue}if(t.offset<=i&&r.offset<o&&r.offset>i||t.offset>i&&t.offset<o&&r.offset>=o){let e=t.offset<=i?i:t.offset,l=r.offset>=o?o:r.offset;n.push(s.slice(e,l)),e===i?n.push(s.slice(l,o)):l===o&&n.push(s.slice(i,e));continue}let l=t.offset,f=r.offset;n.push(s.slice(i,l)),n.push(s.slice(l,f)),n.push(s.slice(f,o))}s=n}return s}},l={isElement:e=>o(e)&&Array.isArray(e.children)&&0===e.children.filter((e=>!i.isText(e)&&!l.isElement(e))).length&&"string"==typeof e.type,isElementList(e){return Array.isArray(e)&&e.every((e=>this.isElement(e)))},isElementProps:e=>void 0!==e.children&&void 0!==e.type,isElementType(e,t,s="type"){return this.isElement(e)&&e[s]===t},matches(e,t){for(const s in t)if("children"!==s&&"type"!==s&&(!e.hasOwnProperty(s)||e[s]!==t[s]))return!1;return!0}},f={};export{f as EditorUtils,l as ElementUtils,r as LocationUtils,e as PathUtils,t as PointUtils,s as RangeUtils,i as TextUtils};
