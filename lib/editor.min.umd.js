!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Editor={})}(this,(function(e){"use strict";const t={isPath:e=>Array.isArray(e)&&0===e.filter((e=>"number"!=typeof e)).length,equals(e,t){for(let s in e)if(e[s]!==t[s])return!1;return e.length===t.length},compare(e,t){const s=Math.min(e.length,t.length);for(let r=0;r<s;r++){if(e[r]<t[r])return-1;if(e[r]>t[r])return 1}return 0},ancestors(e){let t=[];for(let s=0;s<e.length;s++)t.push(e.slice(0,s+1));return t},common(e,t){let s=[],r=Math.min(e.length,t.length);for(let n=0;n<r&&e[n]===t[n];n++)s.push(e[n]);return s},isAfter(e,t){return 1===this.compare(e,t)},isAncestor(e,t){return e.length<t.length&&0===this.compare(e,t)},isDescendant(e,t){return e.length>t.length&&0===this.compare(e,t)},isChild(e,t){return e.length===t.length+1&&0===this.compare(e,t)},isBefore(e,t){return-1===this.compare(e,t)},next(e){if(0===e.length)throw new Error("传入的path的数组长度不能为0");let t=e[e.length-1];return e.slice(0,e.length-1).concat(t+1)},before(e){if(0===e.length)throw new Error("传入的path的数组长度不能为0");let t=e[e.length-1];if(0===t)throw new Error("传入的path不存在前继节点");return e.slice(0,e.length-1).concat(t-1)},endsAfter(e,t){const s=e.length-1,r=e.slice(0,s),n=t.slice(0,s),o=e[s],i=t[s];return this.equals(r,n)&&o>i},endsBefore(e,t){const s=e.length-1,r=e.slice(0,s),n=t.slice(0,s),o=e[s],i=t[s];return this.equals(r,n)&&o<i},endsAt(e,t){const s=e.length-1,r=e.slice(0,s),n=t.slice(0,s);return e[s],t[s],this.equals(r,n)},transform(e,t,s={}){let r=[...e],{path:n}=t,{direction:o="forward"}=s;switch(t.type){case"insert_node":(this.isAncestor(n,r)||this.endsBefore(n,r)||this.equals(r,n)||this.isBefore(n,r))&&r[n.length-1]++;break;case"remove_node":if(this.endsAfter(r,n)||this.isAfter(r,n))r[n.length]--;else if(this.equals(r,n)||this.isAncestor(n,r))return null;break;case"merge_node":this.equals(n,r)||this.endsBefore(n,r)||this.isBefore(n,r)?r[n.length-1]--:this.isAncestor(n,r)&&(r[n.length-1]--,r[n.length]+=t.count);break;case"split_node":this.equals(n,r)?"forward"===o||r[r.length-1]++:this.endsBefore(n,r)||this.isBefore(n,r)?r[n.length-1]++:this.isAncestor(n,r)&&r[n.length]>=t.count&&(r[n.length-1]++,r[n.length]-=t.count);break;case"move_node":let{newPath:e}=t;if(this.equals(n,e))return null;this.equals(n,r)?(this.endsAfter(e,n)&&e.length>n.length&&e[n.length]--,r=e):this.isAncestor(n,r)?(this.endsAfter(e,n)&&e.length>n.length&&e[n.length]--,r=e.concat(r.slice(n.length,r.length))):this.endsBefore(n,r)?(r[n.length-1]--,(this.endsBefore(e,r)||this.equals(e,r))&&r[e.length-1]++):this.endsBefore(e,r)?r[e.length-1]++:this.equals(e,r)&&r[r.length-1]++}return r}},s={compare(e,s){let r=t.compare(e.path,s.path);return 0===r?e.offset>s.offset?1:e.offset<s.offset?-1:0:r},isAfter(e,t){return 1===this.compare(e,t)},isBefore(e,t){return-1===this.compare(e,t)},equals:(e,s)=>t.equals(e.path,s.path)&&e.offset===s.offset,isPoint:e=>e.path&&e.offset&&t.isPath(e.path)&&"number"==typeof e.offset,transform(e,s,r={}){const{type:n,path:o}=s;let i=Object.assign({},e);switch(n){case"move_node":case"insert_node":i.path=t.transform(i.path,s,r);break;case"merge_node":i.path=t.transform(i.path,s,r),t.equals(i.path,o)&&(i.offset+=s.count);break;case"split_node":i.path=t.transform(i.path,s,r),t.equals(i.path,o)&&i.offset>=s.count&&(i.offset-=s.count);break;case"remove_node":if(t.equals(i.path,o)||t.isAncestor(o,i.path))return null;t.transform(i.path,s,r);break;case"insert_text":t.equals(i.path,o)&&i.offset>=s.offset&&(i.offset+=s.text.length);break;case"remove_text":if(t.equals(i.path,o)&&i.offset>s.offset){if(i.offset-s.offset<s.text.length)return null;i.offset-=s.text.length}}return i}},r={edges(e){let{from:t,to:s}=e;return[t,s]},end(e){let{from:t,to:s}=e;return s},equals:(e,t)=>s.equals(e.from,t.from)&&s.equals(e.to,t.to),includes(e,n){let{from:o,to:i}=e;if(t.isPath(n))return t.compare(o.path,n)<=0&&t.compare(i.path,n)>=0;if(s.isPoint(n))return s.compare(o,n)<=0&&s.compare(i,n)>=0;if(r.isRange(n)){let{from:t,to:s}=n;return r.includes(e,t)&&r.includes(e,s)}},intersection(e,t){let[n,o]=r.edges(e),[i,l]=r.edges(t),f=s.isAfter(n,i)?n:i,h=s.isBefore(o,l)?o:l;return s.isAfter(f,h)?null:{from:f,to:h}},isBackward(e){let[t,n]=r.edges(e);return s.isAfter(t,n)},isCollapsed(e){let[t,n]=r.edges(e);return s.equals(t,n)},isExpanded:e=>!r.isCollapsed(e),isForward:e=>!r.isBackward(e),isRange:e=>e.from&&s.isPoint(e.from)&&e.to&&s.isPoint(e.to),*points(e){yield[e.from,"from"],yield[e.to,"to"]},start(e){let{from:t}=e;return t}},n={isLocation:e=>t.isPath(e)||s.isPoint(e)||r.isRange(e)};
/*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
function o(e){return"[object Object]"===Object.prototype.toString.call(e)}function i(e){var t,s;return!1!==o(e)&&(void 0===(t=e.constructor)||!1!==o(s=t.prototype)&&!1!==s.hasOwnProperty("isPrototypeOf"))}const l={isText:e=>i(e)&&e.text&&"string"==typeof e.text,equals:(e,t)=>e.text===t.text,isTextList(e){return Array.isArray(e)&&0===e.filter((e=>!this.isText(e))).length},matches(e,t){for(const s in t)if("text"!==s&&(!e.hasOwnProperty(s)||e[s]!==t[s]))return!1;return!0},decorations(e,t){let s=[Object.assign({},e)];for(let e of t){let{from:t,to:r}=e,n=[],o=0;for(let e of s){let{text:s}=e,i=o;if(o+=s.length,r.offset<=i||t.offset>=o){n.push(e);continue}if(t.offset<=i&&r.offset>=o){n.push(e);continue}if(t.offset<=i&&r.offset<o&&r.offset>i||t.offset>i&&t.offset<o&&r.offset>=o){let e=t.offset<=i?i:t.offset,l=r.offset>=o?o:r.offset;n.push(s.slice(e,l)),e===i?n.push(s.slice(l,o)):l===o&&n.push(s.slice(i,e));continue}let l=t.offset,f=r.offset;n.push(s.slice(i,l)),n.push(s.slice(l,f)),n.push(s.slice(f,o))}s=n}return s}},f={isElement:e=>i(e)&&Array.isArray(e.children)&&0===e.children.filter((e=>!l.isText(e)&&!f.isElement(e))).length&&"string"==typeof e.type,isElementList(e){return Array.isArray(e)&&e.every((e=>this.isElement(e)))},isElementProps:e=>void 0!==e.children&&void 0!==e.type,isElementType(e,t,s="type"){return this.isElement(e)&&e[s]===t},matches(e,t){for(const s in t)if("children"!==s&&"type"!==s&&(!e.hasOwnProperty(s)||e[s]!==t[s]))return!1;return!0}};e.EditorUtils={},e.ElementUtils=f,e.LocationUtils=n,e.PathUtils=t,e.PointUtils=s,e.RangeUtils=r,e.TextUtils=l,Object.defineProperty(e,"__esModule",{value:!0})}));
